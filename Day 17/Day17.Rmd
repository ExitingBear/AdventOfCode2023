---
title: "Day 17 Notebook"
output: html_notebook
---

```{r setup, include=FALSE}
library(sets)
library(knitr)
library(dplyr)
library(stringr)
library(tidyverse)
library(igraph)
library(ggplot2)
library(rgl)
library(ggraph)
library(readr)
library(ds4psy)
library(numbers)
options(scipen = 999)
```

I got this to work, found the answer, was disappointed that it took the better part of an hour, tried to refine it, broke it. Refined some more. Broke it again. Finally fixed it.

## Part 1

Setup the lavafield matrix

```{r}
input <- read_lines("Day17Sample.txt")
lavafield<-matrix(ncol=nchar(input[1]),nrow=0)
for(i in 1:length(input)){
lavafield<-rbind(lavafield,as.numeric(unlist(str_split(input[i],""))))}
coledge<-ncol(lavafield)
rowedge<-nrow(lavafield)
```

Function - takes in everything (start point, end points, min distance allowed before a turn, max distance allowed before a turn, and, of course, the lavafield.)

Steps:

Start: set up a priority queue. Add the starting point but Up/Down & Right/Left

Repeat from here:

1.  Grab the lowest priority.

2.  Checks:

    +  have we been there before? if so, back to Step 1

    +  is this the end? if so, stop. (because of the way priority is calculated, this must be the lowest possible option. Anything that comes later must already have a higher heatloss already or in a best case scenario would have an equal or higher heat once it reached the end. )

5.  Find all the possible moves from that spot (if we got there going left/right, the moves are up/down & vice versa.)

6.  Add them to the queue where priority = heatloss to that spot+manhattan distance (which is the lowest possible heatloss - assuming it found a trail of all 1s from that point forward)

end repeat

```{r}
lowestheatloss<-function(startx=1,starty=1,endx=13,endy=13,mindist=1,maxdist=3,lf=lavafield){
  ### create a priority queue
  lavaqueue<-collections::priority_queue()
  ### start by pushing the start to the queue in RL & UD directions
  max_x<-ncol(lf)
  max_y<-nrow(lf)
  lavaqueue$push(tuple("RL",startx,starty,0),priority=0)
  lavaqueue$push(tuple("UD",startx,starty,0),priority=0)
  out<-0
  beenthere<-collections::dict()
  #### begin while
  while(lavaqueue$size()>0){
    currentstep<-lavaqueue$pop()
    orientation<-currentstep[[1]]
    currentx<-currentstep[[2]]
    currenty<-currentstep[[3]]
    currentheat<-currentstep[[4]]
    if(currentx==endx&&currenty==endy){
      out=currentheat
      break}
    if(beenthere$has(paste(orientation,currentx,currenty))){next
      }else{beenthere$set(key=paste(orientation,currentx,currenty),value=paste(currentstep))}
    newheat<-currentheat
    newx<-currentx
    newy<-currenty
    ### if current orientation is RL, find the next steps to the right
    if(orientation=="RL"){
      ### find to the right
      i<-1
      newx<-currentx+1
      newheat<-currentheat
      while(newx>=1&&newx<=max_x&&i<=maxdist){
        newheat<-newheat+lf[newy,newx]
        ###add to priority queue in if i>=minimumdistance.
        ###because priority goes from biggest to smallest, priority is -(heatloss+manhattan distance to the endpoint).
        if(i>=mindist){lavaqueue$push(tuple("UD",newx,newy,newheat),priority=-(newheat+(endx-newx)+(endy-newy)))}
        newx<-newx+1
        i<-i+1}
      ###reset and go to the left.
      i<-1
      newx<-currentx-1
      newheat<-currentheat
      while(newx>=1&&newx<=max_x&&i<=maxdist){
        newheat<-newheat+lf[newy,newx]
        ###add to priority queue in if i>=minimumdistance.
        ###because priority goes from biggest to smallest, priority is -(heatloss+manhattan distance to the endpoint)
        if(i>=mindist){lavaqueue$push(tuple("UD",newx,newy,newheat),priority=-(newheat+(endx-newx)+(endy-newy)))}
        newx<-newx-1
        ### stop when i hits the maxlength
        i<-i+1}
      ### otherwise if orientation is UD, find the possibilities up and down
    }else if(orientation=="UD"){
      ### first look down
      i<-1
      newy<-currenty+1
      newheat<-currentheat
      while(newy>=1&&newy<=max_y&&i<=maxdist){
        newheat<-newheat+lf[newy,newx]
        ###add to priority queue in if i>=minimumdistance.
        ###because priority goes from biggest to smallest, priority is -(heatloss+manhattan distance to the endpoint)
        if(i>=mindist){lavaqueue$push(tuple("RL",newx,newy,newheat),priority=-(newheat+(endx-newx)+(endy-newy)))}
        newy<-newy+1
        i<-i+1}
      ###reset and go up
      i<-1
      newy<-currenty-1
      newheat<-currentheat
      while(newy>=1&&newy<=max_y&&i<=maxdist){
        newheat<-newheat+lf[newy,newx]
        ###add to priority queue in if i>=minimumdistance.
        ###because priority goes from biggest to smallest, priority is -(heatloss+manhattan distance to the endpoint)
        if(i>=mindist){lavaqueue$push(tuple("RL",newx,newy,newheat),priority=-(newheat+(endx-newx)+(endy-newy)))}
        newy<-newy-1
        ### stop when i hits the maxlength
        i<-i+1}}}
  out}
```

```{r}
part1<-lowestheatloss(1,1,coledge,rowedge,1,3,lavafield)
part1
```

## Part 2

The lowest & highest number of blocks are already built into the function. Re-run.

```{r}
part2<-lowestheatloss(1,1,coledge,rowedge,4,10,lavafield)
part2
```

Stuck both together and here it is:

```{r}
day17answers <-function(lavafield){
  coledge<-ncol(lavafield)
  rowedge<-nrow(lavafield)
  part1 <-lowestheatloss(1,1,coledge,rowedge,1,3,lavafield)
  part2 <-lowestheatloss(1,1,coledge,rowedge,4,10,lavafield)
  
  c(part1,part2)}

```

```{r}
day17 <- day17answers(lavafield)
day17
```
