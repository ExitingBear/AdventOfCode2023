---
title: "Day 3 Notebook"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
library(knitr)
library(dplyr)
library(stringr)
library(tidyverse)
library(igraph)
library(ggplot2)
library(rgl)
library(ggraph)
library(readr)
options(scipen = 999)


```

```{r}
# Read in data
mydata <- read_lines("Day3Sample.txt")

```

## Part 1
We're looking for all of the numbers that are touching at least one not-number.

To start, let's read this into a matrix surrounded by a row of periods on the top, bottom, and each side (because that will make the future parts easier.) I am assuming that all of the lines will have the same number of characters - because that's how squares work (I tried read.fwf().  It did not like that.)

I'm also making a slight change - if I find a number, I'm checking the next two spaces to find out how many digits it is.  Then, I'm labeling all of those spaces with a code "row~starting column;number" For example

...934...
would become
| . | . | . |1~4;934|1~4;934|1~4;934| . | . | . |

That way, I know that the number "934" stretches across those three spaces, starting at row 1, column 4.  This is useful later. I swear

```{r}
datarows<-length(mydata)
datacols<-nchar(mydata[1])

mymatrix <- matrix(ncol=datacols+2,nrow=datarows+2)
mymatrix[1,]<-"."
mymatrix[datarows+2,]<-"."
mymatrix[,1]<-"."
mymatrix[,datacols+2]<-"."

for (i in 1:datarows){
  thisline <- mydata[i]
  j<-1
  while(j<=datacols){
    ##check upcoming three spaces
    curpoint<-str_sub(thisline,j,j)
    nxtpoint<-str_sub(thisline,j+1,j+1)
    dubnext<-str_sub(thisline,j+2,j+2)
    ##update if needed
    if(str_detect(curpoint,"[0123456789]")&str_detect(nxtpoint,"[0123456789]")&str_detect(dubnext,"[0123456789]")){
      mymatrix[i+1,j+1]<-paste0(i,"~",j,";",str_sub(thisline,j,j+2))
      mymatrix[i+1,j+2]<-paste0(i,"~",j,";",str_sub(thisline,j,j+2))
      mymatrix[i+1,j+3]<-paste0(i,"~",j,";",str_sub(thisline,j,j+2))
      j<-j+3}else if(str_detect(curpoint,"[0123456789]")&str_detect(nxtpoint,"[0123456789]")){
        mymatrix[i+1,j+1]<-paste0(i,"~",j,";",str_sub(thisline,j,j+1))
        mymatrix[i+1,j+2]<-paste0(i,"~",j,";",str_sub(thisline,j,j+1))
        j<-j+2}else if(str_detect(curpoint,"[0123456789]")){
          mymatrix[i+1,j+1]<-paste0(i,"~",j,";",str_sub(thisline,j,j))
          j<-j+1}else{
            ### otherwise if it is just a symbol or a period, put that in the matrix
            mymatrix[i+1,j+1]<-curpoint
            j<-j+1}}}
```


Now, with a matrix of everything, I want to grab all of the symbols and everything that surrounds them and put that into a dataframe (because if a number is touching a symbol, the symbol is also touching a number. So I just need the symbols:

```{r}
symbols <- as.data.frame(matrix(ncol=9,nrow=0))

for(i in 2:datarows+1){
  for(j in 2:datacols+1){
    ## check to see if this is one of the .'s or one of the numbers. "~" is not one of the symbols in the dataset.
    if(mymatrix[i,j]!="." & !str_detect(mymatrix[i,j],"~")){
      addit<-c(mymatrix[i,j],
               mymatrix[i+1,j+1],
               mymatrix[i+1,j],
               mymatrix[i+1,j-1],
               mymatrix[i,j-1],
               mymatrix[i,j+1],
               mymatrix[i-1,j+1],
               mymatrix[i-1,j],
               mymatrix[i-1,j-1])
      symbols<-rbind(symbols,addit)}}}

colnames(symbols)<-c("point","P1","P2","P3","P4","P5","P6","P7","P8") # The Ps go around the 
### how many symbols total?
nrow(symbols)
###
symbols[1:5,]


```


The above is an example - row 1 shows a symbol "*" and it is next to two of the digits in the number 35 that starts at row 3, column 3. It is also next to one of the digits of the number 467 at row 1, column 1

Now, just collect all of the unique values in columns A-H (those are the numbers touching a part)
```{r}
### get numbers - the reason that the coordinate values were used earlier is to make sure that if a number appeared twice in the matrix, it was counted twice; but if the same number was touching multiple parts, it is only counted once
parts <- unique(c(symbols$P1,symbols$P2,symbols$P3,symbols$P4,symbols$P5,symbols$P6,symbols$P7,symbols$P8))

### remove "."
parts <- parts[!parts=="."]

### pull out numbers
parts <- as.numeric(str_split_i(parts,";",2))

part1<-sum(parts)

part1
```

## Part 2
For part 2 - the focus is on the gears - so first find them  (the symbol "*")
```{r}
gears <- symbols %>% filter(point == "*")

gears[1:min(8,nrow(gears)),]
```

And we're looking for gears that are touching two numbers - grab P1-P8 and find the unique values (not including the "."s)


```{r}
gears <- gears %>% rowwise%>% mutate(partlist=list(c(P1,P2,P3,P4,P5,P6,P7,P8))) %>%
  mutate(partlist=list(unique(partlist))) %>%
  mutate(partlist=list(partlist[!partlist=="."])) %>%
  ### the only things that matter are the gearlist - but we may as well keep the point, just for fun
  select(point,partlist)

gears[1:min(8,nrow(gears)),]
```

At this point, filter out anything that is only touching 1 thing. Instead just look at gears touching two numbers and get those numbers.  Then multiply them.

```{r}
gears <- gears %>%
  filter(length(partlist)==2) %>%
  mutate(p1=partlist[1],p2=partlist[2]) %>%
  mutate(p1=as.numeric(str_split_i(p1,";",2)),p2=as.numeric(str_split_i(p2,";",2))) %>%
  mutate(gearratio=p1*p2)

gears[1:min(8,nrow(gears)),]

```
And finally, part 2 is the sum of the gear ratios

```{r}
part2 <- sum(gears$gearratio)
part2
```

In a single function


```{r}
### starts with the data already read in using read_lines()
day3answers<-function(input){
  datarows<-length(input)
  datacols<-nchar(input[1])
  
  ### read data into matrix
  mymatrix <- matrix(ncol=datacols+2,nrow=datarows+2)
  mymatrix[1,]<-"."
  mymatrix[datarows+2,]<-"."
  mymatrix[,1]<-"."
  mymatrix[,datacols+2]<-"."
  
  for (i in 1:datarows){
    thisline <- input[i]
    j<-1
    while(j<=datacols){
      ##check upcoming three spaces
      curpoint<-str_sub(thisline,j,j)
      nxtpoint<-str_sub(thisline,j+1,j+1)
      dubnext<-str_sub(thisline,j+2,j+2)
      ##update if needed
      if(str_detect(curpoint,"[0123456789]")&str_detect(nxtpoint,"[0123456789]")&str_detect(dubnext,"[0123456789]")){
        mymatrix[i+1,j+1]<-paste0(i,"~",j,";",str_sub(thisline,j,j+2))
        mymatrix[i+1,j+2]<-paste0(i,"~",j,";",str_sub(thisline,j,j+2))
        mymatrix[i+1,j+3]<-paste0(i,"~",j,";",str_sub(thisline,j,j+2))
        j<-j+3}else if(str_detect(curpoint,"[0123456789]")&str_detect(nxtpoint,"[0123456789]")){
          mymatrix[i+1,j+1]<-paste0(i,"~",j,";",str_sub(thisline,j,j+1))
          mymatrix[i+1,j+2]<-paste0(i,"~",j,";",str_sub(thisline,j,j+1))
          j<-j+2}else if(str_detect(curpoint,"[0123456789]")){
            mymatrix[i+1,j+1]<-paste0(i,"~",j,";",str_sub(thisline,j,j))
            j<-j+1}else{
              ### otherwise if it is just a symbol or a period, put that in the matrix
              mymatrix[i+1,j+1]<-curpoint
              j<-j+1}}}
  
  ### create data frame of symbols
  symbols <- as.data.frame(matrix(ncol=9,nrow=0))

  for(i in 2:datarows+1){
    for(j in 2:datacols+1){
      ## check to see if this is one of the .'s or one of the numbers. "~" is not one of the symbols in the dataset.
      if(mymatrix[i,j]!="." & !str_detect(mymatrix[i,j],"~")){
        addit<-c(mymatrix[i,j],
                 mymatrix[i+1,j+1],
                 mymatrix[i+1,j],
                 mymatrix[i+1,j-1],
                 mymatrix[i,j-1],
                 mymatrix[i,j+1],
                 mymatrix[i-1,j+1],
                 mymatrix[i-1,j],
                 mymatrix[i-1,j-1])
        symbols<-rbind(symbols,addit)}}}
  
  colnames(symbols)<-c("point","P1","P2","P3","P4","P5","P6","P7","P8")
  
  ###get parts from the numbers touching at least one symbol
  parts <- unique(c(symbols$P1,symbols$P2,symbols$P3,symbols$P4,symbols$P5,symbols$P6,symbols$P7,symbols$P8))
  parts <- parts[!parts=="."]
  parts <- as.numeric(str_split_i(parts,";",2))
  
  part1<-sum(parts)
  
  ###get gears
  gears <- symbols %>% filter(point == "*") %>%
    rowwise %>%
    ### get the list of parts touching the gears
    mutate(partlist=list(c(P1,P2,P3,P4,P5,P6,P7,P8))) %>%
    mutate(partlist=list(unique(partlist))) %>%
    mutate(partlist=list(partlist[!partlist=="."])) %>%
    select(point,partlist) %>%
    ### list get parts & calculate gear ratio
    filter(length(partlist)==2) %>%
    mutate(p1=partlist[1],p2=partlist[2]) %>%
    mutate(p1=as.numeric(str_split_i(p1,";",2)),p2=as.numeric(str_split_i(p2,";",2))) %>%
    mutate(gearratio=p1*p2)
  
  part2 <- sum(gears$gearratio)

  return(c(part1,part2))}

```


```{r}
day3answers(mydata)
```

